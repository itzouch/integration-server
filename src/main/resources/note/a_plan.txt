1. java finsh
collection、juc、thread、synchronized、volatile

2. redis数据类型

3、redis集群备份和同步

4、mysql复习

5、mysql日志系统

6、JVM内存区域

7、JVM垃圾回收

8、Spring

9、Kafka

10、单例、工厂、策略、观察者、代理、装饰、责任链...

回忆了一下，还问了我们项目的并发量，qps，怎么管理扩容的，有没有优化空间。有个问题我没答上来就是分布式应用场景下本地缓存+redis+db数据同步问题，其他的真的没啥了

还有一个分库分表的问题，问我什么时候应该考虑分库，什么时候考虑分表
业务复杂，单库性能达到瓶颈。按业务分库。
分表前先优化可以优化的地方，比如sql，表结构，或者加机器。加冗余字段等等。  迫不得已进行分表，取余法，按时间分也可以。 此时要考虑id唯一的问题，可以用美团雪花算法模式。
第一位不用 2-42保存当前时间减去一个特定时间的时间戳。后端保存机器id和自增的一个id。


1.https原理，是不是绝对安全，和http对比，tcp的几个阶段，time_waited和close_WAIT
答：不是绝对安全，需要防范中间人攻击。
tcp三个阶段，握手，数据传输，挥手。  established表示正在通信，time_waited是主动关闭状态，close_wait是被动关闭状态.

2.为什么会保持time_waitedt状态
答：可靠的关闭TCP连接。在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，
就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。另外这么设计TIME_WAIT 会定时的回收资源，并不会占用很大资源的，除非短时间内接受大量请求或者受到攻击。


问了time_waited过多怎么办？什么导致的？怎么排查
半连接全连接队列，溢出怎么检查