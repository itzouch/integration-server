# hashmap-完结

a | b 或运算    一个为真则为真
a & b 与运算    都为真才为真
a ^ 0 异或运算   两个不同为真
">>>" 移位运算

结构：
- 1.7前，数组+链表
- 1.8及以后，数组+链表/红黑树

1. 为什么在为8的时候转二叉树？
时间和空间平衡的结果，节点太少时，红黑树查找性能并不明显，付出二倍代价不值得。
    
2. 为什么由红黑树转为链表是节点为6？
如果节点个数在8徘徊，就会造成红黑树和链表的频繁转换，非常浪费性能。

3. 为什么初始化容量是16？
16正好是2的N次方，其他值也可，最好自己默认。

4. 为什么负载因子是0.75？
时间和空间折中的选择，小于0.75可能会造成hash冲突增加，大于0.75又会浪费空间。

5. put的流程？
    1. 计算key的hash值，然后判断数组是否为空，是则初始化数组，默认大小为16。
    2. 计算索引位置，计算公式是：（n-1）& hash
    3. 找到对应的索引，判断头结点key是否相同，相同直接覆盖。
    4. 不相同则插入，红黑树要自平衡，链表的话尾插法。
    
6. hash值的计算方法是？
先拿到hashcode,然后将hashcode的高16位进行异或运算。
目的是为了让hash值的高低位都参与运算。

7. 扩容
当在put时，发现容量已经达到负载因子计算出的值，这时会扩容。
扩容的新值一定是2的N次方，具体是大于当前所需容量值的最小的2的N次方。那为什么是2的N次方？
首先这个等式是成立的  x mod 2^n = x & (2^n - 1)，且&比mod具有更高的效率。
由5可知计算索引下标公式是（n-1）& hash，只有在n为2的N次方时，n-1为低位全是1的值，和取余的效果相同！实现了key的均匀分布。
